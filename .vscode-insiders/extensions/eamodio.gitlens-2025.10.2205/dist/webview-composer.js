exports.id=407,exports.ids=[407],exports.modules={9762:(e,t,o)=>{o.d(t,{ComposerWebviewProvider:()=>ComposerWebviewProvider});var i=o(1398),n=o(6202),s=o(6695),a=o(3182),r=o(5773),c=o(41),d=o(6402),m=o(9827),h=o(7820),l=o(4684),g=o(994);let u="1.0.0",p={hunks:[],commits:[],baseCommit:null,selectedCommitId:null,selectedCommitIds:new Set,selectedUnassignedSection:null,selectedHunkIds:new Set,detailsSectionExpanded:{commitMessage:!0,aiExplanation:!0,filesChanged:!0},generatingCommits:!1,generatingCommitMessage:null,committing:!1,safetyError:null,loadingError:null,aiOperationError:null,hasUsedAutoCompose:!1,hasChanges:!0,workingDirectoryHasChanged:!1,indexHasChanged:!1,mode:"preview",aiEnabled:{org:!1,config:!1},ai:{model:void 0},onboardingDismissed:!1},f={sessionStart:"",sessionDuration:void 0,diff:{files:0,hunks:0,lines:0,staged:!1,unstaged:!1,unstagedIncluded:!1},commits:{initialCount:0,autoComposedCount:void 0,composedCount:void 0,finalCount:void 0},ai:{enabled:{org:!1,config:!1},model:void 0},onboarding:{dismissed:!1,stepReached:void 0},operations:{generateCommits:{count:0,cancelledCount:0,errorCount:0,feedback:{upvoteCount:0,downvoteCount:0}},generateCommitMessage:{count:0,cancelledCount:0,errorCount:0},finishAndCommit:{errorCount:0},undo:{count:0},redo:{count:0},reset:{count:0}},source:void 0,mode:"preview",errors:{safety:{count:0},operation:{count:0}},warnings:{workingDirectoryChanged:!1,indexChanged:!1}},C="composer",x=new g.Q2(C,"generateCommits"),y=new g.Q2(C,"generateCommitMessage"),_=new g.Q2(C,"finishAndCommit"),w=new g.Q2(C,"close"),b=new g.Q2(C,"reload"),v=new g.Q2(C,"cancelGenerateCommits"),k=new g.Q2(C,"cancelGenerateCommitMessage");new g.Q2(C,"cancelFinishAndCommit");let I=new g.Q2(C,"clearAIOperationError"),E=new g.Q2(C,"selectAIModel"),R=new g.Q2(C,"aiFeedbackHelpful"),S=new g.Q2(C,"aiFeedbackUnhelpful"),M=new g.Q2(C,"openOnboarding"),A=new g.Q2(C,"dismissOnboarding"),T=new g.Q2(C,"advanceOnboarding"),D=new g.Q2("composer","chooseRepository"),F=new g.Q2(C,"onAddHunksToCommit"),O=new g.Q2(C,"onUndo"),H=new g.Q2(C,"onRedo"),P=new g.Q2(C,"onReset"),$=new g.C1(C,"didStartGenerating"),Q=new g.C1(C,"didStartGeneratingCommitMessage"),U=new g.C1(C,"didGenerateCommits"),G=new g.C1(C,"didGenerateCommitMessage"),N=new g.C1(C,"didStartCommitting"),W=new g.C1(C,"didFinishCommitting"),B=new g.C1(C,"didSafetyError"),z=new g.C1(C,"didReloadComposer"),q=new g.C1(C,"didLoadingError"),j=new g.C1(C,"didWorkingDirectoryChange"),L=new g.C1(C,"didIndexChange"),V=new g.C1(C,"didCancelGenerateCommits"),Z=new g.C1(C,"didCancelGenerateCommitMessage"),J=new g.C1(C,"didErrorAIOperation"),K=new g.C1(C,"didClearAIOperationError"),X=new g.C1(C,"didChangeAiEnabled"),Y=new g.C1(C,"didChangeAiModel");var ee=o(8887);function et(e){if(0===e.length)return{patch:"",filePatches:new Map};let t=new Map;for(let o of e){let e=o.diffHeader||`diff --git a/${o.fileName} b/${o.fileName}`,i=t.get(e);if(null==i&&(i=[],t.set(e,i)),o.isRename)i.push("");else{let e=`${o.hunkHeader}
${o.content}`;i.push(e)}}let o="";for(let[e,i]of t.entries()){o+=`${e.trim()}
`;let t=i.filter(e=>""!==e.trim());t.length>0&&(o+=`${t.join(`
`)}
`)}return{patch:o,filePatches:t}}function eo(e,t,o){let i=[],n=o;for(let o of e.files)if(o.hunks.length)for(let e of o.hunks){let s=++n,{additions:a,deletions:r}=function(e){let t=e.split(`
`),o=0,i=0;for(let e of t)e.startsWith("+")&&!e.startsWith("+++")?o++:e.startsWith("-")&&!e.startsWith("---")&&i++;return{additions:o,deletions:i}}(e.content),c={index:s,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e.header,content:e.content,additions:a,deletions:r,source:t,assigned:!1,isRename:!1};i.push(c)}else{let e,s,a=++n;if(o.metadata.binary)e="binary",s="Binary file";else if(o.metadata.modeChanged)e="mode change",s=`Mode change from ${o.metadata.modeChanged.oldMode||"?"} to ${o.metadata.modeChanged.newMode||"?"}`;else if(o.metadata.renamedOrCopied){e="rename";let t=o.metadata.renamedOrCopied?.similarity||100;s=`Rename from ${o.originalPath}
Rename to ${o.path}
Similarity index ${t}%`}else e="no-content-change",s=o.header.split(`
`).slice(1).join(`
`);let r={index:a,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e,content:s,additions:0,deletions:0,source:t,assigned:!1,isRename:!1!==o.metadata.renamedOrCopied};i.push(r)}return{hunks:i,count:n}}async function ei(e){let[t,o,i]=await Promise.allSettled([e.git.diff.getDiff?.(a.id),e.git.diff.getDiff?.(a.SU),e.git.diff.getDiff?.(a.SU,"HEAD",{notation:"..."})]);return{staged:(0,h.Ro)(t),unstaged:(0,h.Ro)(o),unified:(0,h.Ro)(i)}}async function en(e,t,o){return{repoPath:e.path,headSha:o??null,hashes:{staged:t.staged?.contents?await (0,n.sc)(t.staged.contents):null,unstaged:t.unstaged?.contents?await (0,n.sc)(t.unstaged.contents):null,unified:t.unified?.contents?await (0,n.sc)(t.unified.contents):null}}}async function es(e,t,o,i){let s=[];try{e.path!==t.repoPath&&s.push(`Repository path changed from "${t.repoPath}" to "${e.path}"`);let a=await e.git.commits.getCommit("HEAD"),r=a?.sha??null;if(r!==t.headSha&&s.push(`HEAD commit changed from "${t.headSha}" to "${r}"`),o?.length){let{staged:a,unstaged:r}=i??await ei(e),c={staged:a?.contents?await (0,n.sc)(a.contents):null,unstaged:r?.contents?await (0,n.sc)(r.contents):null};o.some(e=>"staged"===e.source)&&c.staged!==t.hashes.staged&&s.push("Staged changes have been modified since composer opened"),o.some(e=>"unstaged"===e.source)&&c.unstaged!==t.hashes.unstaged&&s.push("Unstaged changes have been modified since composer opened")}return{isValid:!s.length,errors:s}}catch(e){return s.push(`Failed to validate repository state: ${e instanceof Error?e.message:"Unknown error"}`),{isValid:!1,errors:s}}}let ComposerWebviewProvider=class ComposerWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=i.Disposable.from(d.H.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,m.wt)(this.onContextChanged,this),this.container.ai.onDidChangeModel(this.onAIModelChanged,this)),this._context={...f},this._safetyState={repoPath:"",headSha:"",hashes:{staged:null,unstaged:null,unified:null}}}_disposable;_args;_cache=new l.o({accessTTL:3e5});_generateCommitsCancellation;_generateCommitMessageCancellation;_repositorySubscription;_currentRepository;_hunks=[];_safetyState;_context;_ignoreIndexChange=!1;dispose(){this._cache.clear(),this.resetContext(),this._generateCommitsCancellation?.dispose(),this._generateCommitMessageCancellation?.dispose(),this._repositorySubscription?.dispose(),this._disposable.dispose()}onMessageReceived(e){switch(!0){case x.is(e):this.onGenerateCommits(e.params);break;case y.is(e):this.onGenerateCommitMessage(e.params);break;case _.is(e):this.onFinishAndCommit(e.params);break;case w.is(e):this.close();break;case b.is(e):this.onReloadComposer(e.params);break;case E.is(e):this.onSelectAIModel();break;case R.is(e):this.onAIFeedbackHelpful(e.params);break;case S.is(e):this.onAIFeedbackUnhelpful(e.params);break;case v.is(e):this.onCancelGenerateCommits();break;case k.is(e):this.onCancelGenerateCommitMessage();break;case I.is(e):this.onClearAIOperationError();break;case M.is(e):this.onOpenOnboarding();break;case T.is(e):this.onAdvanceOnboarding(e.params);break;case A.is(e):this.onDismissOnboarding();break;case F.is(e):this.onAddHunksToCommit(e.params);break;case O.is(e):this.onUndo();break;case H.is(e):this.onRedo();break;case P.is(e):this.onReset();break;case D.is(e):this.onChooseRepository()}}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.session.start":this._context.sessionStart,"context.session.duration":this._context.sessionDuration,"context.source":this._context.source,"context.mode":this._context.mode,"context.diff.files.count":this._context.diff.files,"context.diff.hunks.count":this._context.diff.hunks,"context.diff.lines.count":this._context.diff.lines,"context.diff.staged.exists":this._context.diff.staged,"context.diff.unstaged.exists":this._context.diff.unstaged,"context.diff.unstaged.included":this._context.diff.unstagedIncluded,"context.commits.initialCount":this._context.commits.initialCount,"context.commits.autoComposedCount":this._context.commits.autoComposedCount,"context.commits.composedCount":this._context.commits.composedCount,"context.commits.finalCount":this._context.commits.finalCount,"context.ai.enabled.config":this._context.ai.enabled.config,"context.ai.enabled.org":this._context.ai.enabled.org,"context.ai.model.id":this._context.ai.model?.id,"context.ai.model.name":this._context.ai.model?.name,"context.ai.model.provider.id":this._context.ai.model?.provider.id,"context.ai.model.temperature":this._context.ai.model?.temperature??void 0,"context.ai.model.maxTokens.input":this._context.ai.model?.maxTokens.input,"context.ai.model.maxTokens.output":this._context.ai.model?.maxTokens.output,"context.ai.model.default":this._context.ai.model?.default,"context.ai.model.hidden":this._context.ai.model?.hidden,"context.onboarding.stepReached":this._context.onboarding.stepReached,"context.onboarding.dismissed":this._context.onboarding.dismissed,"context.operations.generateCommits.count":this._context.operations.generateCommits.count,"context.operations.generateCommits.cancelled.count":this._context.operations.generateCommits.cancelledCount,"context.operations.generateCommits.error.count":this._context.operations.generateCommits.errorCount,"context.operations.generateCommits.feedback.upvote.count":this._context.operations.generateCommits.feedback.upvoteCount,"context.operations.generateCommits.feedback.downvote.count":this._context.operations.generateCommits.feedback.downvoteCount,"context.operations.generateCommitMessage.count":this._context.operations.generateCommitMessage.count,"context.operations.generateCommitMessage.cancelled.count":this._context.operations.generateCommitMessage.cancelledCount,"context.operations.generateCommitMessage.error.count":this._context.operations.generateCommitMessage.errorCount,"context.operations.finishAndCommit.error.count":this._context.operations.finishAndCommit.errorCount,"context.operations.undo.count":this._context.operations.undo.count,"context.operations.redo.count":this._context.operations.redo.count,"context.operations.reset.count":this._context.operations.reset.count,"context.warnings.workingDirectoryChanged":this._context.warnings.workingDirectoryChanged,"context.warnings.indexChanged":this._context.warnings.indexChanged,"context.errors.safety.count":this._context.errors.safety.count,"context.errors.operation.count":this._context.errors.operation.count}}includeBootstrap(e){return this._cache.get("bootstrap",()=>this.getBootstrapState())}async getBootstrapState(){let e;this.container.git.isDiscoveringRepositories&&await this.container.git.isDiscoveringRepositories;let t=this._args;return null==(e=t?.repoPath!=null?this.container.git.getRepository(t.repoPath):this.container.git.getBestRepositoryOrFirst())?{...this.initialState,loadingError:"No repository found. Please open a Git repository to use the Commit Composer."}:this.createInitialStateFromRepo(e,t?.includedUnstagedChanges,t?.mode,t?.source)}get initialState(){return{...this.host.baseWebviewState,...p}}async createInitialStateFromRepo(e,t,o="preview",i,n){this._repositorySubscription?.dispose();let s=(await e.git.status?.getUntrackedFiles())?.map(e=>e.path);if(s?.length)try{await e.git.staging?.stageFiles(s,{intentToAdd:!0}),this._ignoreIndexChange=!0}catch{}let[a,r,c]=await Promise.allSettled([ei(e),e.git.commits.getCommit("HEAD"),e.git.branches.getBranch()]);s?.length&&await e.git.staging?.unstageFiles(s).catch();let d=(0,h.Ro)(a);this._context.diff.unstagedIncluded=!1,t&&(this._context.diff.unstagedIncluded=!0);let m=this._context.diff.unstagedIncluded?d?.unified:d?.staged,l=this._context.diff.unstagedIncluded?void 0:d?.unstaged;!d?.staged?.contents&&d?.unstaged?.contents&&(this._context.diff.unstagedIncluded=!0);let g=!!(m?.contents||l?.contents),u=function(e,t){let o=[],i=0,n=[];if(e){let t=(0,ee.Tc)(e);({hunks:n,count:i}=eo(t,"staged",i)),o.push(...n)}if(t){let e=(0,ee.Tc)(t);({hunks:n,count:i}=eo(e,"unstaged",i)),o.push(...n)}return o}(m?.contents,l?.contents);this._hunks=u;let p=(0,h.Ro)(r),f=(0,h.Ro)(c),C=!!m?.contents,x=!!l?.contents,y={id:"draft-commit-1",message:"",aiExplanation:"",hunkIndices:C&&x?u.filter(e=>"staged"===e.source).map(e=>e.index):u.map(e=>e.index)},_=await en(e,d,p?.sha);this._safetyState=_;let w=this.getAiEnabled(),b=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId}),v=this.isOnboardingDismissed(),k=this.getOnboardingStepReached();return this._context.diff.files=new Set(u.map(e=>e.fileName)).size,this._context.diff.hunks=u.length,this._context.diff.lines=u.reduce((e,t)=>e+t.content.split(`
`).length-1,0),this._context.diff.staged=C,this._context.diff.unstaged=x,this._context.commits.initialCount=0,this._context.ai.enabled.org=w.org,this._context.ai.enabled.config=w.config,this._context.ai.model=b,this._context.onboarding.dismissed=v,this._context.onboarding.stepReached=k,this._context.source=i,this._context.mode=o,this._context.warnings.workingDirectoryChanged=!1,this._context.warnings.indexChanged=!1,this._context.sessionStart=new Date().toISOString(),this.sendTelemetryEvent(n?"composer/reloaded":"composer/loaded"),this.subscribeToRepository(e),{...this.initialState,hunks:u,baseCommit:p?{sha:p.sha,message:p.message??"",repoName:e.name,branchName:f?.name??"main"}:null,commits:g?[y]:[],aiEnabled:w,ai:{model:b},hasChanges:g,mode:o,onboardingDismissed:v,workingDirectoryHasChanged:!1,indexHasChanged:!1,repositoryState:this.getRepositoryState()}}getRepositoryState(){if(null==this._currentRepository)return;let{id:e,name:t,path:o,uri:i,virtual:n}=this._currentRepository;return{current:{id:e,name:t,path:o,uri:i.toString(),virtual:n},hasMultipleRepositories:this.container.git.openRepositoryCount>1}}async onAddHunksToCommit(e){"unstaged"===e.source&&(this._context.diff.unstagedIncluded=!0,this.sendTelemetryEvent("composer/action/includedUnstagedChanges"),await this.onReloadComposer({repoPath:this._currentRepository.path,mode:this._context.mode}))}onUndo(){this._context.operations.undo.count++,this.sendTelemetryEvent("composer/action/undo")}onRedo(){this._context.operations.redo.count++}onReset(){this._context.operations.reset.count++,this.sendTelemetryEvent("composer/action/reset")}async onChooseRepository(){let{title:e,placeholder:t}=await (0,c.Nt)(this.container.git.openRepositories,"Switch",this._currentRepository?.name),o=await (0,c.oe)(this.container,e,t,this.container.git.openRepositories,{picked:this._currentRepository});null!=o&&await this.onReloadComposer({repoPath:o.path,source:"composer"})}async onReloadComposer(e){try{this._cache.clear();let t=this._currentRepository;if((!t||null!=e.repoPath&&t?.path!==e.repoPath)&&!(t=null==e.repoPath?this.container.git.getBestRepositoryOrFirst():this.container.git.getRepository(e.repoPath))){this._context.errors.safety.count++;let e="Repository is no longer available";this.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(B,{error:e});return}let o=await this.createInitialStateFromRepo(t,this._context.diff.unstagedIncluded,e.mode,e.source,!0);if(o.loadingError)return void await this.host.notify(q,{error:o.loadingError});await this.host.notify(z,{hunks:o.hunks,commits:o.commits,baseCommit:o.baseCommit,loadingError:o.loadingError,hasChanges:o.hasChanges,repositoryState:o.repositoryState})}catch(e){this.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(q,{error:e instanceof Error?e.message:"Failed to reload composer"})}}async onCancelGenerateCommits(){this._generateCommitsCancellation&&(this._generateCommitsCancellation.cancel(),await this.host.notify(V,void 0))}async onCancelGenerateCommitMessage(){this._generateCommitMessageCancellation&&(this._generateCommitMessageCancellation.cancel(),await this.host.notify(Z,void 0))}async onClearAIOperationError(){await this.host.notify(K,void 0)}onOpenOnboarding(){this.advanceOnboardingStep(1)}onAdvanceOnboarding(e){this.advanceOnboardingStep(e.stepNumber)}advanceOnboardingStep(e){if(this.isOnboardingDismissed())return;let t=Math.max(this.container.storage.get("composer:onboarding:stepReached")??1,e);this._context.onboarding.stepReached=t,this.container.storage.store("composer:onboarding:stepReached",t).catch()}onDismissOnboarding(){this.isOnboardingDismissed()||(this._context.onboarding.dismissed=!0,this.container.storage.store("composer:onboarding:dismissed",u).catch())}isOnboardingDismissed(){return this.container.storage.get("composer:onboarding:dismissed")===u}getOnboardingStepReached(){return this.container.storage.get("composer:onboarding:stepReached")}resetContext(){this._context={...f}}onShowing(e,t,...o){return o?.[0]&&(this._cache.clear(),this.resetContext(),this._args=o[0],this.updateTitle(o[0].mode)),[!0,void 0]}updateTitle(e){"experimental"===(e??this._args?.mode??"preview")?this.host.title="Commit Composer (Experimental)":this.host.title="Commit Composer (Preview)"}async close(){this._context.sessionDuration=Date.now()-new Date(this._context.sessionStart).getTime(),await i.commands.executeCommand("workbench.action.closeActiveEditor")}async updateAiModel(){try{let e=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});this._context.ai.model=e,this.sendTelemetryEvent("composer/action/changeAiModel"),await this.host.notify(Y,{model:e})}catch{}}async onSelectAIModel(){await i.commands.executeCommand("gitlens.ai.switchProvider",{source:"composer",correlationId:this.host.instanceId,detail:"model-picker"})}async onAIFeedbackHelpful(e){this._context.operations.generateCommits.feedback.upvoteCount++,await this.sendComposerAIFeedback("helpful",e.sessionId)}async onAIFeedbackUnhelpful(e){this._context.operations.generateCommits.feedback.downvoteCount++,await this.sendComposerAIFeedback("unhelpful",e.sessionId)}async sendComposerAIFeedback(e,t){try{let o,i=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});if(!i)return;let n={id:t||"composer-session",type:"generate-commits",feature:"composer",model:{id:i.id,name:i.name,maxTokens:i.maxTokens,provider:{id:i.provider.id,name:i.provider.name},default:i.default,hidden:i.hidden,temperature:i.temperature},usage:void 0};if("unhelpful"===e&&(o=await (0,r.E)(),void 0===o))return;(0,r._)(this.container,{source:"composer",correlationId:this.host.instanceId},n,e,o)}catch{}}subscribeToRepository(e){this._repositorySubscription?.dispose(),this._currentRepository=e,this._repositorySubscription=i.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(this.onRepositoryFileSystemChanged,this),e.onDidChange(this.onRepositoryChanged,this))}async onRepositoryChanged(e){if(e.repository.id!==this._currentRepository?.id)return;let t=this._ignoreIndexChange;this._ignoreIndexChange=!1,!e.changed(s.Z_.Index,s.Ti.Any)||t&&e.changed(s.Z_.Index,s.Ti.Exclusive)||(this._context.warnings.indexChanged=!0,await this.host.notify(L,void 0))}async onRepositoryFileSystemChanged(e){e.repository.id===this._currentRepository?.id&&(this._context.warnings.workingDirectoryChanged=!0,await this.host.notify(j,void 0))}async onGenerateCommits(e){let t={"customInstructions.used":!1,"customInstructions.length":0,"customInstructions.hash":"","customInstructions.setting.used":!1,"customInstructions.setting.length":0};try{let o=d.H.get("ai.generateCommits.customInstructions");o&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=o.length),this._context.operations.generateCommits.count++,e.customInstructions&&(t["customInstructions.used"]=!0,t["customInstructions.length"]=e.customInstructions.length,t["customInstructions.hash"]=(0,n.Fx)(e.customInstructions)),this._generateCommitsCancellation=new i.CancellationTokenSource,await this.host.notify($,void 0);let s=[];for(let t of e.hunkIndices)s.push({...this._hunks.find(e=>e.index===t),assigned:!0});let a=e.commits.map(e=>({id:e.id,message:e.message,aiExplanation:e.aiExplanation,hunkIndices:e.hunkIndices})),r=await this.container.ai.generateCommits(s,a,this._hunks.map(e=>({index:e.index,hunkHeader:e.hunkHeader})),{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitsCancellation.token,customInstructions:e.customInstructions});if(this._generateCommitsCancellation?.token.isCancellationRequested){this._context.operations.generateCommits.cancelledCount++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(V,void 0);return}if(r&&"cancelled"!==r){if(0===r.commits.length){this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"no commits generated"}),await this.host.notify(J,{operation:"generate commits",error:"No commits generated"});return}let o=r.commits.map((e,t)=>({id:`ai-commit-${t}`,message:e.message,aiExplanation:e.explanation,hunkIndices:e.hunks.map(e=>e.hunk)}));this._context.commits.autoComposedCount=o.length,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose":"composer/action/compose",t),await this.host.notify(U,{commits:o})}else"cancelled"===r?(this._context.operations.generateCommits.cancelledCount++,await this.host.notify(V,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(J,{operation:"generate commits",error:void 0}))}catch(o){this._generateCommitsCancellation?.token.isCancellationRequested?(this._context.operations.generateCommits.cancelledCount++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(V,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":o instanceof Error?o.message:"unknown error"}),await this.host.notify(J,{operation:"generate commits",error:o instanceof Error?o.message:void 0}))}finally{this._generateCommitsCancellation?.dispose(),this._generateCommitsCancellation=void 0}}async onGenerateCommitMessage(e){let t={"customInstructions.setting.used":!1,"customInstructions.setting.length":0,overwriteExistingMessage:e.overwriteExistingMessage??!1};try{let o=d.H.get("ai.generateCommitMessage.customInstructions");o&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=o.length),this._context.operations.generateCommitMessage.count++,this._generateCommitMessageCancellation=new i.CancellationTokenSource,await this.host.notify(Q,{commitId:e.commitId});let{patch:n}=et(this._hunks.filter(t=>e.commitHunkIndices.includes(t.index)));n||(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":"Failed to create diff for commit"}),await this.host.notify(J,{operation:"generate commit message",error:"Failed to create diff for commit"}));let s=await this.container.ai.generateCommitMessage(n,{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitMessageCancellation.token});if(this._generateCommitMessageCancellation?.token.isCancellationRequested){this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Z,void 0);return}if(s&&"cancelled"!==s){let o=s.parsed.body?`${s.parsed.summary}

${s.parsed.body}`:s.parsed.summary;this.sendTelemetryEvent("composer/action/generateCommitMessage",t),await this.host.notify(G,{commitId:e.commitId,message:o})}else"cancelled"===s?(this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Z,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(J,{operation:"generate commit message",error:void 0}))}catch(e){this._generateCommitMessageCancellation?.token.isCancellationRequested?(this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Z,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(J,{operation:"generate commit message",error:e instanceof Error?e.message:void 0}))}finally{this._generateCommitMessageCancellation?.dispose(),this._generateCommitMessageCancellation=void 0}}async onFinishAndCommit(e){try{var t;let o,s,r;await this.host.notify(N,void 0);let c=this.container.git.getRepository(this._safetyState.repoPath);if(!c){await this.host.notify(W,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++;let e="Repository is no longer available";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(B,{error:e});return}let d=e.commits.flatMap(e=>e.hunkIndices),m=[];for(let e of d)m.push({...this._hunks.find(t=>t.index===e),assigned:!0});let h=m.filter(t=>e.commits.some(e=>e.hunkIndices.includes(t.index)));if(this._context.diff.unstagedIncluded){this._repositorySubscription?.dispose();let e=(await c.git.status?.getUntrackedFiles())?.map(e=>e.path);if(e?.length)try{o=await ei(c),await c.git.staging?.stageFiles(e)}catch{}}let l=await es(c,this._safetyState,h,o);if(!l.isValid){await this.host.notify(W,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=l.errors.join(`
`);this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(B,{error:e});return}let g=(t=e.commits,t.map(e=>{let{patch:t,filePatches:o}=et(m.filter(t=>e.hunkIndices.includes(t.index)));return{message:e.message,explanation:e.aiExplanation,filePatches:o,patch:t}})),u=this.container.git.getRepositoryService(c.path);if(!u){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="No repository service found";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}if(e.baseCommit?.sha==null){let e=await u.patch?.createEmptyInitialCommit();if(null==e){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Could not create base commit";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}}let p=await c.git.patch?.createUnreachableCommitsFromPatches(e.baseCommit?.sha,g);if(!p?.length){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to create commits from patches";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}let f=e.baseCommit?.sha??(await c.git.commits.getCommit("HEAD")?"HEAD":a.BI),C=(await c.git.diff.getDiff?.(p[p.length-1],f,{notation:e.baseCommit?.sha?"...":void 0}))?.contents;if(!C){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to get combined diff";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}if(!function(e,t,o){let{hashes:i}=e;return t===(o?i.unified:i.staged)}(this._safetyState,await (0,n.sc)(C),this._context.diff.unstagedIncluded)){await this.host.notify(W,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Output diff does not match input";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(B,{error:e});return}let x=await u.stash?.getStash();if(x?.stashes.size){let e=x.stashes.values().next().value;e&&(s=e)}let y=`Commit composer: ${new Date().toLocaleString()}`;await u.stash?.saveStash(y,void 0,{includeUntracked:!0}),x=await u.stash?.getStash();let _=!1;x?.stashes.size&&(r=x.stashes.values().next().value)&&r.ref!==s?.ref&&r.message?.includes(y)&&(_=!0),await u.reset(p[p.length-1],{hard:!0}),r&&_&&await u.stash?.applyStash(r.stashName,{deleteAfter:!0}),this._context.commits.finalCount=p.length,this.sendTelemetryEvent("composer/action/finishAndCommit"),await this.host.notify(W,void 0),i.commands.executeCommand("workbench.action.closeActiveEditor")}catch(t){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=t instanceof Error?t.message:"unknown error";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,void 0),i.window.showErrorMessage(`Failed to commit changes: ${e}`)}}onAnyConfigurationChanged(e){if(d.H.changed(e,"ai.enabled")){let e=d.H.get("ai.enabled",void 0,!0);this._context.ai.enabled.config=e,this.host.notify(X,{config:e})}}onContextChanged(e){if("gitlens:gk:organization:ai:enabled"===e){let e=(0,m.SD)("gitlens:gk:organization:ai:enabled",!0);this._context.ai.enabled.org=e,this.host.notify(X,{org:e})}}onAIModelChanged(e){this.updateAiModel()}getAiEnabled(){return{org:(0,m.SD)("gitlens:gk:organization:ai:enabled",!0),config:d.H.get("ai.enabled",void 0,!0)}}sendTelemetryEvent(e,t){this.container.telemetry.enabled&&this.container.telemetry.sendEvent(e,{...this.getTelemetryContext(),...t})}}}};